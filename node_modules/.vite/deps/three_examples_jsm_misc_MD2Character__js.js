import {
  AnimationClip,
  AnimationMixer,
  Box3,
  BufferGeometry,
  FileLoader,
  Float32BufferAttribute,
  Loader,
  Mesh,
  MeshLambertMaterial,
  Object3D,
  SRGBColorSpace,
  TextureLoader,
  UVMapping,
  Vector3
} from "./chunk-UG26MVNH.js";

// node_modules/three/examples/jsm/loaders/MD2Loader.js
var _normalData = [
  [-0.525731, 0, 0.850651],
  [-0.442863, 0.238856, 0.864188],
  [-0.295242, 0, 0.955423],
  [-0.309017, 0.5, 0.809017],
  [-0.16246, 0.262866, 0.951056],
  [0, 0, 1],
  [0, 0.850651, 0.525731],
  [-0.147621, 0.716567, 0.681718],
  [0.147621, 0.716567, 0.681718],
  [0, 0.525731, 0.850651],
  [0.309017, 0.5, 0.809017],
  [0.525731, 0, 0.850651],
  [0.295242, 0, 0.955423],
  [0.442863, 0.238856, 0.864188],
  [0.16246, 0.262866, 0.951056],
  [-0.681718, 0.147621, 0.716567],
  [-0.809017, 0.309017, 0.5],
  [-0.587785, 0.425325, 0.688191],
  [-0.850651, 0.525731, 0],
  [-0.864188, 0.442863, 0.238856],
  [-0.716567, 0.681718, 0.147621],
  [-0.688191, 0.587785, 0.425325],
  [-0.5, 0.809017, 0.309017],
  [-0.238856, 0.864188, 0.442863],
  [-0.425325, 0.688191, 0.587785],
  [-0.716567, 0.681718, -0.147621],
  [-0.5, 0.809017, -0.309017],
  [-0.525731, 0.850651, 0],
  [0, 0.850651, -0.525731],
  [-0.238856, 0.864188, -0.442863],
  [0, 0.955423, -0.295242],
  [-0.262866, 0.951056, -0.16246],
  [0, 1, 0],
  [0, 0.955423, 0.295242],
  [-0.262866, 0.951056, 0.16246],
  [0.238856, 0.864188, 0.442863],
  [0.262866, 0.951056, 0.16246],
  [0.5, 0.809017, 0.309017],
  [0.238856, 0.864188, -0.442863],
  [0.262866, 0.951056, -0.16246],
  [0.5, 0.809017, -0.309017],
  [0.850651, 0.525731, 0],
  [0.716567, 0.681718, 0.147621],
  [0.716567, 0.681718, -0.147621],
  [0.525731, 0.850651, 0],
  [0.425325, 0.688191, 0.587785],
  [0.864188, 0.442863, 0.238856],
  [0.688191, 0.587785, 0.425325],
  [0.809017, 0.309017, 0.5],
  [0.681718, 0.147621, 0.716567],
  [0.587785, 0.425325, 0.688191],
  [0.955423, 0.295242, 0],
  [1, 0, 0],
  [0.951056, 0.16246, 0.262866],
  [0.850651, -0.525731, 0],
  [0.955423, -0.295242, 0],
  [0.864188, -0.442863, 0.238856],
  [0.951056, -0.16246, 0.262866],
  [0.809017, -0.309017, 0.5],
  [0.681718, -0.147621, 0.716567],
  [0.850651, 0, 0.525731],
  [0.864188, 0.442863, -0.238856],
  [0.809017, 0.309017, -0.5],
  [0.951056, 0.16246, -0.262866],
  [0.525731, 0, -0.850651],
  [0.681718, 0.147621, -0.716567],
  [0.681718, -0.147621, -0.716567],
  [0.850651, 0, -0.525731],
  [0.809017, -0.309017, -0.5],
  [0.864188, -0.442863, -0.238856],
  [0.951056, -0.16246, -0.262866],
  [0.147621, 0.716567, -0.681718],
  [0.309017, 0.5, -0.809017],
  [0.425325, 0.688191, -0.587785],
  [0.442863, 0.238856, -0.864188],
  [0.587785, 0.425325, -0.688191],
  [0.688191, 0.587785, -0.425325],
  [-0.147621, 0.716567, -0.681718],
  [-0.309017, 0.5, -0.809017],
  [0, 0.525731, -0.850651],
  [-0.525731, 0, -0.850651],
  [-0.442863, 0.238856, -0.864188],
  [-0.295242, 0, -0.955423],
  [-0.16246, 0.262866, -0.951056],
  [0, 0, -1],
  [0.295242, 0, -0.955423],
  [0.16246, 0.262866, -0.951056],
  [-0.442863, -0.238856, -0.864188],
  [-0.309017, -0.5, -0.809017],
  [-0.16246, -0.262866, -0.951056],
  [0, -0.850651, -0.525731],
  [-0.147621, -0.716567, -0.681718],
  [0.147621, -0.716567, -0.681718],
  [0, -0.525731, -0.850651],
  [0.309017, -0.5, -0.809017],
  [0.442863, -0.238856, -0.864188],
  [0.16246, -0.262866, -0.951056],
  [0.238856, -0.864188, -0.442863],
  [0.5, -0.809017, -0.309017],
  [0.425325, -0.688191, -0.587785],
  [0.716567, -0.681718, -0.147621],
  [0.688191, -0.587785, -0.425325],
  [0.587785, -0.425325, -0.688191],
  [0, -0.955423, -0.295242],
  [0, -1, 0],
  [0.262866, -0.951056, -0.16246],
  [0, -0.850651, 0.525731],
  [0, -0.955423, 0.295242],
  [0.238856, -0.864188, 0.442863],
  [0.262866, -0.951056, 0.16246],
  [0.5, -0.809017, 0.309017],
  [0.716567, -0.681718, 0.147621],
  [0.525731, -0.850651, 0],
  [-0.238856, -0.864188, -0.442863],
  [-0.5, -0.809017, -0.309017],
  [-0.262866, -0.951056, -0.16246],
  [-0.850651, -0.525731, 0],
  [-0.716567, -0.681718, -0.147621],
  [-0.716567, -0.681718, 0.147621],
  [-0.525731, -0.850651, 0],
  [-0.5, -0.809017, 0.309017],
  [-0.238856, -0.864188, 0.442863],
  [-0.262866, -0.951056, 0.16246],
  [-0.864188, -0.442863, 0.238856],
  [-0.809017, -0.309017, 0.5],
  [-0.688191, -0.587785, 0.425325],
  [-0.681718, -0.147621, 0.716567],
  [-0.442863, -0.238856, 0.864188],
  [-0.587785, -0.425325, 0.688191],
  [-0.309017, -0.5, 0.809017],
  [-0.147621, -0.716567, 0.681718],
  [-0.425325, -0.688191, 0.587785],
  [-0.16246, -0.262866, 0.951056],
  [0.442863, -0.238856, 0.864188],
  [0.16246, -0.262866, 0.951056],
  [0.309017, -0.5, 0.809017],
  [0.147621, -0.716567, 0.681718],
  [0, -0.525731, 0.850651],
  [0.425325, -0.688191, 0.587785],
  [0.587785, -0.425325, 0.688191],
  [0.688191, -0.587785, 0.425325],
  [-0.955423, 0.295242, 0],
  [-0.951056, 0.16246, 0.262866],
  [-1, 0, 0],
  [-0.850651, 0, 0.525731],
  [-0.955423, -0.295242, 0],
  [-0.951056, -0.16246, 0.262866],
  [-0.864188, 0.442863, -0.238856],
  [-0.951056, 0.16246, -0.262866],
  [-0.809017, 0.309017, -0.5],
  [-0.864188, -0.442863, -0.238856],
  [-0.951056, -0.16246, -0.262866],
  [-0.809017, -0.309017, -0.5],
  [-0.681718, 0.147621, -0.716567],
  [-0.681718, -0.147621, -0.716567],
  [-0.850651, 0, -0.525731],
  [-0.688191, 0.587785, -0.425325],
  [-0.587785, 0.425325, -0.688191],
  [-0.425325, 0.688191, -0.587785],
  [-0.425325, -0.688191, -0.587785],
  [-0.587785, -0.425325, -0.688191],
  [-0.688191, -0.587785, -0.425325]
];
var MD2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      try {
        onLoad(scope.parse(buffer));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(buffer) {
    const data = new DataView(buffer);
    const header = {};
    const headerNames = [
      "ident",
      "version",
      "skinwidth",
      "skinheight",
      "framesize",
      "num_skins",
      "num_vertices",
      "num_st",
      "num_tris",
      "num_glcmds",
      "num_frames",
      "offset_skins",
      "offset_st",
      "offset_tris",
      "offset_frames",
      "offset_glcmds",
      "offset_end"
    ];
    for (let i = 0; i < headerNames.length; i++) {
      header[headerNames[i]] = data.getInt32(i * 4, true);
    }
    if (header.ident !== 844121161 || header.version !== 8) {
      console.error("Not a valid MD2 file");
      return;
    }
    if (header.offset_end !== data.byteLength) {
      console.error("Corrupted MD2 file");
      return;
    }
    const geometry = new BufferGeometry();
    const uvsTemp = [];
    let offset = header.offset_st;
    for (let i = 0, l = header.num_st; i < l; i++) {
      const u = data.getInt16(offset + 0, true);
      const v = data.getInt16(offset + 2, true);
      uvsTemp.push(u / header.skinwidth, 1 - v / header.skinheight);
      offset += 4;
    }
    offset = header.offset_tris;
    const vertexIndices = [];
    const uvIndices = [];
    for (let i = 0, l = header.num_tris; i < l; i++) {
      vertexIndices.push(
        data.getUint16(offset + 0, true),
        data.getUint16(offset + 2, true),
        data.getUint16(offset + 4, true)
      );
      uvIndices.push(
        data.getUint16(offset + 6, true),
        data.getUint16(offset + 8, true),
        data.getUint16(offset + 10, true)
      );
      offset += 12;
    }
    const translation = new Vector3();
    const scale = new Vector3();
    const frames = [];
    offset = header.offset_frames;
    for (let i = 0, l = header.num_frames; i < l; i++) {
      scale.set(
        data.getFloat32(offset + 0, true),
        data.getFloat32(offset + 4, true),
        data.getFloat32(offset + 8, true)
      );
      translation.set(
        data.getFloat32(offset + 12, true),
        data.getFloat32(offset + 16, true),
        data.getFloat32(offset + 20, true)
      );
      offset += 24;
      const string = [];
      for (let j = 0; j < 16; j++) {
        const character = data.getUint8(offset + j);
        if (character === 0) break;
        string[j] = character;
      }
      const frame = {
        name: String.fromCharCode.apply(null, string),
        vertices: [],
        normals: []
      };
      offset += 16;
      for (let j = 0; j < header.num_vertices; j++) {
        let x = data.getUint8(offset++);
        let y = data.getUint8(offset++);
        let z = data.getUint8(offset++);
        const n = _normalData[data.getUint8(offset++)];
        x = x * scale.x + translation.x;
        y = y * scale.y + translation.y;
        z = z * scale.z + translation.z;
        frame.vertices.push(x, z, y);
        frame.normals.push(n[0], n[2], n[1]);
      }
      frames.push(frame);
    }
    const positions = [];
    const normals = [];
    const uvs = [];
    const verticesTemp = frames[0].vertices;
    const normalsTemp = frames[0].normals;
    for (let i = 0, l = vertexIndices.length; i < l; i++) {
      const vertexIndex = vertexIndices[i];
      let stride = vertexIndex * 3;
      const x = verticesTemp[stride];
      const y = verticesTemp[stride + 1];
      const z = verticesTemp[stride + 2];
      positions.push(x, y, z);
      const nx = normalsTemp[stride];
      const ny = normalsTemp[stride + 1];
      const nz = normalsTemp[stride + 2];
      normals.push(nx, ny, nz);
      const uvIndex = uvIndices[i];
      stride = uvIndex * 2;
      const u = uvsTemp[stride];
      const v = uvsTemp[stride + 1];
      uvs.push(u, v);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    const morphPositions = [];
    const morphNormals = [];
    for (let i = 0, l = frames.length; i < l; i++) {
      const frame = frames[i];
      const attributeName = frame.name;
      if (frame.vertices.length > 0) {
        const positions2 = [];
        for (let j = 0, jl = vertexIndices.length; j < jl; j++) {
          const vertexIndex = vertexIndices[j];
          const stride = vertexIndex * 3;
          const x = frame.vertices[stride];
          const y = frame.vertices[stride + 1];
          const z = frame.vertices[stride + 2];
          positions2.push(x, y, z);
        }
        const positionAttribute = new Float32BufferAttribute(positions2, 3);
        positionAttribute.name = attributeName;
        morphPositions.push(positionAttribute);
      }
      if (frame.normals.length > 0) {
        const normals2 = [];
        for (let j = 0, jl = vertexIndices.length; j < jl; j++) {
          const vertexIndex = vertexIndices[j];
          const stride = vertexIndex * 3;
          const nx = frame.normals[stride];
          const ny = frame.normals[stride + 1];
          const nz = frame.normals[stride + 2];
          normals2.push(nx, ny, nz);
        }
        const normalAttribute = new Float32BufferAttribute(normals2, 3);
        normalAttribute.name = attributeName;
        morphNormals.push(normalAttribute);
      }
    }
    geometry.morphAttributes.position = morphPositions;
    geometry.morphAttributes.normal = morphNormals;
    geometry.morphTargetsRelative = false;
    geometry.animations = AnimationClip.CreateClipsFromMorphTargetSequences(frames, 10);
    return geometry;
  }
};

// node_modules/three/examples/jsm/misc/MD2Character.js
var MD2Character = class {
  constructor() {
    this.scale = 1;
    this.animationFPS = 6;
    this.root = new Object3D();
    this.meshBody = null;
    this.meshWeapon = null;
    this.skinsBody = [];
    this.skinsWeapon = [];
    this.weapons = [];
    this.activeAnimation = null;
    this.mixer = null;
    this.onLoadComplete = function() {
    };
    this.loadCounter = 0;
  }
  loadParts(config) {
    const scope = this;
    function createPart(geometry, skinMap) {
      const materialWireframe = new MeshLambertMaterial({ color: 16755200, wireframe: true });
      const materialTexture = new MeshLambertMaterial({ color: 16777215, wireframe: false, map: skinMap });
      const mesh = new Mesh(geometry, materialTexture);
      mesh.rotation.y = -Math.PI / 2;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.materialTexture = materialTexture;
      mesh.materialWireframe = materialWireframe;
      return mesh;
    }
    function loadTextures(baseUrl, textureUrls) {
      const textureLoader = new TextureLoader();
      const textures = [];
      for (let i = 0; i < textureUrls.length; i++) {
        textures[i] = textureLoader.load(baseUrl + textureUrls[i], checkLoadingComplete);
        textures[i].mapping = UVMapping;
        textures[i].name = textureUrls[i];
        textures[i].colorSpace = SRGBColorSpace;
      }
      return textures;
    }
    function checkLoadingComplete() {
      scope.loadCounter -= 1;
      if (scope.loadCounter === 0) scope.onLoadComplete();
    }
    this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;
    const weaponsTextures = [];
    for (let i = 0; i < config.weapons.length; i++) weaponsTextures[i] = config.weapons[i][1];
    this.skinsBody = loadTextures(config.baseUrl + "skins/", config.skins);
    this.skinsWeapon = loadTextures(config.baseUrl + "skins/", weaponsTextures);
    const loader = new MD2Loader();
    loader.load(config.baseUrl + config.body, function(geo) {
      const boundingBox = new Box3();
      boundingBox.setFromBufferAttribute(geo.attributes.position);
      scope.root.position.y = -scope.scale * boundingBox.min.y;
      const mesh = createPart(geo, scope.skinsBody[0]);
      mesh.scale.set(scope.scale, scope.scale, scope.scale);
      scope.root.add(mesh);
      scope.meshBody = mesh;
      scope.meshBody.clipOffset = 0;
      scope.activeAnimationClipName = mesh.geometry.animations[0].name;
      scope.mixer = new AnimationMixer(mesh);
      checkLoadingComplete();
    });
    const generateCallback = function(index, name) {
      return function(geo) {
        const mesh = createPart(geo, scope.skinsWeapon[index]);
        mesh.scale.set(scope.scale, scope.scale, scope.scale);
        mesh.visible = false;
        mesh.name = name;
        scope.root.add(mesh);
        scope.weapons[index] = mesh;
        scope.meshWeapon = mesh;
        checkLoadingComplete();
      };
    };
    for (let i = 0; i < config.weapons.length; i++) {
      loader.load(config.baseUrl + config.weapons[i][0], generateCallback(i, config.weapons[i][0]));
    }
  }
  setPlaybackRate(rate) {
    if (rate !== 0) {
      this.mixer.timeScale = 1 / rate;
    } else {
      this.mixer.timeScale = 0;
    }
  }
  setWireframe(wireframeEnabled) {
    if (wireframeEnabled) {
      if (this.meshBody) this.meshBody.material = this.meshBody.materialWireframe;
      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialWireframe;
    } else {
      if (this.meshBody) this.meshBody.material = this.meshBody.materialTexture;
      if (this.meshWeapon) this.meshWeapon.material = this.meshWeapon.materialTexture;
    }
  }
  setSkin(index) {
    if (this.meshBody && this.meshBody.material.wireframe === false) {
      this.meshBody.material.map = this.skinsBody[index];
    }
  }
  setWeapon(index) {
    for (let i = 0; i < this.weapons.length; i++) this.weapons[i].visible = false;
    const activeWeapon = this.weapons[index];
    if (activeWeapon) {
      activeWeapon.visible = true;
      this.meshWeapon = activeWeapon;
      this.syncWeaponAnimation();
    }
  }
  setAnimation(clipName) {
    if (this.meshBody) {
      if (this.meshBody.activeAction) {
        this.meshBody.activeAction.stop();
        this.meshBody.activeAction = null;
      }
      const action = this.mixer.clipAction(clipName, this.meshBody);
      if (action) {
        this.meshBody.activeAction = action.play();
      }
    }
    this.activeClipName = clipName;
    this.syncWeaponAnimation();
  }
  syncWeaponAnimation() {
    const clipName = this.activeClipName;
    if (this.meshWeapon) {
      if (this.meshWeapon.activeAction) {
        this.meshWeapon.activeAction.stop();
        this.meshWeapon.activeAction = null;
      }
      const action = this.mixer.clipAction(clipName, this.meshWeapon);
      if (action) {
        this.meshWeapon.activeAction = action.syncWith(this.meshBody.activeAction).play();
      }
    }
  }
  update(delta) {
    if (this.mixer) this.mixer.update(delta);
  }
};
export {
  MD2Character
};
//# sourceMappingURL=three_examples_jsm_misc_MD2Character__js.js.map
